using Minesweeper.Core.Enums;
using Minesweeper.Core.Models;
using Minesweeper.Core;
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Data;
using System.Runtime.CompilerServices;
using System.Data.Common;

namespace Tests.GameProcessorTests.OpenTests
{
    [TestFixture]
    public class OpenTestsRectangularField
    {
        private Minesweeper.Core.GameProcessor? _gameProcessor;
        private int rowLenght = 15;
        private int columnLenght = 114;
        public List<Tuple<int, int>> trueIndex;
        private bool[,]? _field;

        [SetUp]
        public void SetUp()
        {
            trueIndex = new List<Tuple<int, int>> { Tuple.Create(rowLenght - 1, columnLenght - 1), Tuple.Create(rowLenght - 2, columnLenght - 2) };
            _field = generateField(rowLenght, columnLenght, trueIndex);
            _gameProcessor = new Minesweeper.Core.GameProcessor(_field);
        }

        [TearDown]
        public void Postcondition()
        {
        }

        [Test]
        [TestCase(0, 0)]
        public void Open_ReturnGameStateObject_Equal(int x, int y)
        {
            //Precondition
            //trueIndex = new List<Tuple<int, int>> { Tuple.Create(rowLenght - 1, columnLenght - 1), Tuple.Create(rowLenght - 2, columnLenght - 2) };
            //_field = generateField(rowLenght, columnLenght, trueIndex);
            //_gameProcessor = new Minesweeper.Core.GameProcessor(_field);

            //Action and Assert
            Assert.IsInstanceOf<GameState>(_gameProcessor.Open(x, y));
        }

        [Test]
        [TestCase(true)]
        [TestCase(false)]
        public void Open_PlayAfterWinAndLose_ThrowException(bool win)
        {
            //Precondition
            int mines = win ? 0 : rowLenght * columnLenght;
            _field = FieldGenerator.GetRandomField(rowLenght, columnLenght, mines);
            _gameProcessor = new Minesweeper.Core.GameProcessor(_field);

            //Action
            _gameProcessor.Open(0, 0);

            //Assert
            Assert.Throws<InvalidOperationException>(() => _gameProcessor.Open(0, 0));
        }

        [Test]
        [TestCase(true, GameState.Win)]
        [TestCase(false, GameState.Lose)]
        public void Open_ReturnGameState_WinAndLose(bool win, GameState gameStateExpected)
        {
            //Precondition
            int mines = win ? 0 : rowLenght * columnLenght;
            _field = FieldGenerator.GetRandomField(rowLenght, columnLenght, mines);
            _gameProcessor = new Minesweeper.Core.GameProcessor(_field);

            //Action
            GameState gameState = _gameProcessor.Open(0, 0);

            //Assert
            Assert.AreEqual(gameState, gameStateExpected);
        }

        [Test]
        public void Open_WithSameCoordinates_SameState([Values(0, 0)] int x, [Values(0, 0)] int y)
        {
            //Precondition
            //var trueIndex = new List<Tuple<int, int>>{ Tuple.Create(rowLenght - 1, columnLenght - 1), Tuple.Create(rowLenght - 2, columnLenght - 2) };
            //_field = generateField(rowLenght, columnLenght, trueIndex);
            //_gameProcessor = new Minesweeper.Core.GameProcessor(_field);
            GameState expectedGameState = GameState.Active;
            GameState actualGameState;

            //Action
            actualGameState = _gameProcessor.Open(x, y);

            //Assert
            Assert.AreEqual(expectedGameState, actualGameState);
        }

        [Test]
        [TestCase(false, GameState.Win)]
        [TestCase(true, GameState.Lose)]
        public void Open_EveryCell_WinAndLose( bool lose, GameState expectedGameState)
        {
            List<Tuple<int, int>> minesIndex = new();

            minesIndex.Add(Tuple.Create(rowLenght-1, columnLenght-1));
            minesIndex.Add(Tuple.Create(rowLenght-1, columnLenght -3));
            
            _field = generateField(rowLenght, columnLenght, minesIndex);
            _gameProcessor = new Minesweeper.Core.GameProcessor(_field);

            for (int i = 0; i < rowLenght; i++)
            {
                for (int j = 0; j < columnLenght; j++)
                { 
                   if (i != rowLenght - 1 &&  j != columnLenght-1 || i != rowLenght - 1 && j != columnLenght - 3)
                        _gameProcessor.Open(j,i);
                }
            }

            if (lose)
            {
                _gameProcessor.Open(columnLenght - 1, rowLenght - 1);
            }
            else
            {
                _gameProcessor.Open(columnLenght - 2, rowLenght - 1);
            }

            Assert.AreEqual(expectedGameState, _gameProcessor.GameState);
        }

        private bool[,] generateField(int length, int with, List<Tuple<int, int>> trueIndexs)
        {
            bool[,] costumField = new bool[length, with];

            for (int i = 0; i < length - 1; i++)
            {
                for (int j = 0; j < with - 2; j++)
                {

                    costumField[i, j] = false;
                }
            }

            foreach(Tuple<int,int> item in trueIndexs)
            {
                costumField[item.Item1, item.Item2] = true;
            } 

            return costumField;
        }
    }
}
